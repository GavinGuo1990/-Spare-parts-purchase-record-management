<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®¶åº­å‚™å“è³¼è²·ç´€éŒ„è¿½è¹¤å™¨ (IndexedDB)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Configure Tailwind: use 'Inter' font and enable rounded corners -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        // Use Inter and Noto Sans TC for Traditional Chinese characters
                        sans: ['Inter', 'Noto Sans TC', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', 'Noto Sans TC', sans-serif;
            background-color: #f3f4f6;
        }
        /* Hide native arrows for number input */
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { 
            -webkit-appearance: none; 
            margin: 0; 
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8">

    <main class="max-w-7xl mx-auto bg-white shadow-xl rounded-xl p-4 md:p-8">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b pb-2">å‚™å“è³¼è²·ç´€éŒ„ç®¡ç† (æœ¬åœ°å„²å­˜ IndexedDB)</h1>

        <!-- Local Storage Status -->
        <div id="storageStatus" class="text-xs text-blue-500 mb-4 p-2 bg-blue-50 rounded-lg border border-blue-200">
            âœ… è³‡æ–™å„²å­˜åœ¨æ‚¨çš„ç€è¦½å™¨ä¸­ (IndexedDB)ã€‚è³‡æ–™ä¸æœƒåŒæ­¥åˆ°é›²ç«¯ã€‚
        </div>

        <!-- Main Layout: Left Input (1/3), Right Overview (2/3) -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8">

            <!-- Left: Input Form -->
            <div class="lg:col-span-1 p-4 bg-gray-50 rounded-xl shadow-lg h-fit">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">æ–°å¢è³¼è²·ç´€éŒ„</h2>
                <form id="purchaseForm" class="space-y-4">
                    
                    <!-- NEW: Separate Dropdown for Quick Select -->
                    <div>
                        <label for="quickSelect" class="block text-sm font-medium text-gray-700 mb-1">å¾æ­·å²ç´€éŒ„å¿«é€Ÿé¸æ“‡</label>
                        <select id="quickSelect" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 shadow-sm bg-white text-gray-700">
                            <option value="">-- è«‹é¸æ“‡æˆ–æ‰‹å‹•è¼¸å…¥ --</option>
                            <!-- Options dynamically populated by JavaScript -->
                        </select>
                    </div>

                    <!-- Item Name Input (Now just a standard textbox) -->
                    <div>
                        <label for="itemName" class="block text-sm font-medium text-gray-700 mb-1">ç”¢å“åç¨± (æˆ–æ˜¯è¼¸å…¥æ–°ç”¢å“)</label>
                        <input type="text" id="itemName" name="itemName" required
                               class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 shadow-sm"
                               placeholder="è¡›ç”Ÿç´™, æ´—é«®ç²¾, ç‰™åˆ·...">
                    </div>

                    <!-- Purchase Date (Default to today) -->
                    <div>
                        <label for="purchaseDate" class="block text-sm font-medium text-gray-700 mb-1">è³¼è²·æ—¥æœŸ</label>
                        <input type="date" id="purchaseDate" name="purchaseDate" required
                               class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 shadow-sm">
                    </div>

                    <!-- Purchase Amount -->
                    <div>
                        <label for="purchaseAmount" class="block text-sm font-medium text-gray-700 mb-1">è³¼è²·é‡‘é¡ (NT$)</label>
                        <input type="number" id="purchaseAmount" name="purchaseAmount" required min="0" step="any"
                               class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 shadow-sm"
                               placeholder="150">
                    </div>

                    <!-- Purchase Quantity -->
                    <div>
                        <label for="purchaseQuantity" class="block text-sm font-medium text-gray-700 mb-1">è³¼è²·æ•¸é‡</label>
                        <input type="number" id="purchaseQuantity" name="purchaseQuantity" required min="1" step="1"
                               class="w-full p-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500 shadow-sm"
                               placeholder="1">
                    </div>

                    <button type="submit" id="submitButton" disabled
                            class="w-full py-3 px-4 bg-gray-400 text-white font-bold rounded-lg shadow-md transition duration-300 focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed text-lg">
                        è¼‰å…¥ä¸­... (ç­‰å¾…è³‡æ–™åº«é€£ç·š)
                    </button>
                    <div id="formMessage" class="text-sm mt-2 hidden p-2 rounded-lg text-center"></div>
                </form>
            </div>

            <!-- Right: Overview List -->
            <div class="lg:col-span-2 p-4">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">ç”¢å“ä¸Šæ¬¡è³¼è²·æ¦‚è§€</h2>
                <!-- Adaptive grid layout for overview cards -->
                <div id="overviewList" class="grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-3 gap-4">
                    <!-- Overview list will be populated by JavaScript -->
                    <div class="text-gray-500 p-4 bg-white rounded-lg shadow col-span-full">
                        è³‡æ–™åº«é€£ç·šä¸­... è«‹ç¨å€™æˆ–æª¢æŸ¥ IndexedDB æ”¯æ´ã€‚
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom: Annual Purchase Summary -->
        <div class="mt-10 pt-6 border-t border-gray-200">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">ç”¢å“å¹³å‡å¹´è³¼è²·æ•¸é‡åˆ†æ</h2>
            <div id="annualSummary" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                <!-- Summary cards will be populated by JavaScript -->
            </div>
        </div>
    </main>
    
    <!-- Custom Confirmation Modal (Replaces alert/confirm) -->
    <div id="customModal" class="fixed inset-0 bg-gray-900 bg-opacity-75 hidden items-center justify-center z-50 p-4 transition-opacity duration-300">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-sm p-6 space-y-4 transform scale-100 transition-transform duration-300">
            <h3 id="modalTitle" class="text-xl font-bold text-gray-800">ç¢ºèªåˆªé™¤</h3>
            <p id="modalMessage" class="text-gray-600">æ‚¨ç¢ºå®šè¦åˆªé™¤é€™ç­†ç´€éŒ„å—ï¼Ÿ</p>
            <div class="flex justify-end space-x-3">
                <button id="modalCancel" class="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-200 rounded-lg hover:bg-gray-300 transition duration-150">å–æ¶ˆ</button>
                <button id="modalConfirm" class="px-4 py-2 text-sm font-medium text-white bg-red-600 rounded-lg hover:bg-red-700 transition duration-150">ç¢ºå®šåˆªé™¤</button>
            </div>
        </div>
    </div>


    <!-- IndexedDB Logic and Core Application Script -->
    <script>
        // --- IndexedDB Configuration ---
        const DB_NAME = 'PurchaseDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'purchases';

        let db = null;
        let isDbReady = false; 
        
        // Modal elements
        const customModal = document.getElementById('customModal');
        const modalMessage = document.getElementById('modalMessage');
        const modalConfirmBtn = document.getElementById('modalConfirm');
        const modalCancelBtn = document.getElementById('modalCancel');

        // --- IndexedDB Utility Functions (Promise-based Wrapper) ---
        
        /**
         * Opens the IndexedDB connection.
         * @returns {Promise<IDBDatabase>} The IDBDatabase object.
         */
        const openDB = () => {
            return new Promise((resolve, reject) => {
                if (!window.indexedDB) {
                    reject(new Error("æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ IndexedDBã€‚"));
                    return;
                }

                const request = window.indexedDB.open(DB_NAME, DB_VERSION);

                request.onerror = (event) => {
                    console.error("Database error:", event.target.error);
                    reject(event.target.error);
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    isDbReady = true;
                    resolve(db);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        // Create an object store with 'id' as the key path (auto-incrementing)
                        db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                    }
                };
            });
        };

        /**
         * Adds a new item to the object store.
         * Modified: Waits for transaction.oncomplete instead of request.onsuccess
         * @param {object} item - The purchase record to store.
         * @returns {Promise<number>} The ID of the newly added item.
         */
        const addItem = (item) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.add(item);

                // FIX: Use transaction.oncomplete to ensure data is fully committed
                // before resolving. This fixes the issue where data wouldn't show up immediately.
                transaction.oncomplete = () => {
                    resolve(request.result);
                };

                transaction.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        };

        /**
         * Retrieves all items from the object store.
         * @returns {Promise<Array<object>>} An array of all purchase records.
         */
        const getAllItems = () => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readonly');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.getAll();

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        };

        /**
         * Deletes an item by its ID.
         * Modified: Waits for transaction.oncomplete
         * @param {number} id - The ID of the item to delete.
         * @returns {Promise<void>}
         */
        const deleteItem = (id) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction([STORE_NAME], 'readwrite');
                const store = transaction.objectStore(STORE_NAME);
                const request = store.delete(id);

                // FIX: Use transaction.oncomplete to ensure deletion is fully committed
                transaction.oncomplete = () => {
                    resolve();
                };

                transaction.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        };

        // --- Global Helpers ---

        // Helper function: Show notification message
        const showMessage = (message, isError = false) => {
            const msgEl = document.getElementById('formMessage');
            msgEl.textContent = message;
            msgEl.className = isError
                ? 'text-sm mt-2 p-2 rounded-lg text-red-700 bg-red-100 block text-center'
                : 'text-sm mt-2 p-2 rounded-lg text-green-700 bg-green-100 block text-center';
            msgEl.style.display = 'block';
            setTimeout(() => { msgEl.style.display = 'none'; }, 3000);
        };
        
        // Helper function: Format date to YYYY-MM-DD
        const formatDate = (date) => {
            const d = new Date(date);
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${d.getFullYear()}-${month}-${day}`;
        };

        // Helper function: Set date input default to today
        const setInitialDate = () => {
            const dateInput = document.getElementById('purchaseDate');
            if (dateInput) {
                dateInput.value = formatDate(new Date());
            }
        };

        // Helper function: Update submit button state
        const updateSubmitButton = (isReady) => {
            const button = document.getElementById('submitButton');
            if (!button) return;
            
            isDbReady = isReady;

            if (isReady) {
                button.disabled = false;
                button.textContent = 'ğŸ’¾ å„²å­˜ç´€éŒ„';
                button.classList.remove('bg-gray-400');
                button.classList.add('bg-blue-600', 'hover:bg-blue-700', 'focus:ring-blue-500');
            } else {
                button.disabled = true;
                button.textContent = 'è¼‰å…¥ä¸­... (ç­‰å¾…è³‡æ–™åº«é€£ç·š)';
                button.classList.add('bg-gray-400');
                button.classList.remove('bg-blue-600', 'hover:bg-blue-700', 'focus:ring-blue-500');
            }
        };
        
        // --- Custom Modal Functions ---

        /**
         * Shows the custom confirmation modal.
         * @param {string} message - The message to display in the modal.
         * @param {function} onConfirm - Callback function to execute on confirmation.
         */
        const showConfirmModal = (message, onConfirm) => {
            modalMessage.textContent = message;
            customModal.style.display = 'flex'; // Use flex to center

            // Clear previous listeners and set new handlers
            modalConfirmBtn.onclick = null;
            modalCancelBtn.onclick = null;

            const newConfirmHandler = () => {
                customModal.style.display = 'none';
                onConfirm();
            };

            const newCancelHandler = () => {
                customModal.style.display = 'none';
            };

            modalConfirmBtn.addEventListener('click', newConfirmHandler, { once: true });
            modalCancelBtn.addEventListener('click', newCancelHandler, { once: true });
        };


        // --- Core Rendering Functions ---
        
        // Render overview list (right panel)
        const renderOverview = (processedData) => {
            const container = document.getElementById('overviewList');
            container.innerHTML = ''; 

            if (Object.keys(processedData).length === 0) {
                container.innerHTML = `<div class="col-span-1 sm:col-span-2 xl:col-span-3">
                    <p class="text-gray-500 p-4 bg-yellow-50 rounded-lg border border-yellow-200">
                        ç›®å‰æ²’æœ‰ä»»ä½•è³¼è²·ç´€éŒ„ã€‚è«‹åœ¨å·¦å´æ–°å¢ç¬¬ä¸€ç­†ç´€éŒ„ï¼
                    </p>
                </div>`;
                return;
            }

            const sortedItems = Object.entries(processedData)
                .sort(([, a], [, b]) => b.lastDate.getTime() - a.lastDate.getTime()); // Sort by most recent purchase date

            sortedItems.forEach(([name, data]) => {
                const lastDateObj = data.lastDate;
                const lastQuantity = data.lastQuantity; 
                const today = new Date();
                const diffTime = today.getTime() - lastDateObj.getTime();
                const daysSince = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                
                // Get the ID of the latest record (for deletion)
                // We assume the last record in the sorted 'records' array is the latest one
                const lastRecordId = data.records[data.records.length - 1]?.id || null;

                const card = document.createElement('div');
                card.className = 'flex flex-col justify-between items-start p-5 bg-white rounded-xl shadow-lg hover:shadow-xl transition duration-150 border-l-4 border-blue-500 h-full';

                card.innerHTML = `
                    <div class="w-full flex justify-between items-start">
                        <p class="text-xl font-bold text-gray-800 truncate mb-1" title="${name}">${name}</p>
                        <!-- Delete Button (for the latest record) -->
                        ${lastRecordId !== null ? `
                            <button data-id="${lastRecordId}" 
                                    class="delete-btn text-gray-400 hover:text-red-600 transition duration-150 p-1 rounded-full hover:bg-red-50"
                                    title="åˆªé™¤æœ€è¿‘ä¸€ç­†ç´€éŒ„ (${formatDate(lastDateObj)}: ${lastQuantity} ä»½)">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 6h6v10H7V6z" clip-rule="evenodd" />
                                </svg>
                            </button>
                        ` : ''}
                    </div>
                    <div class="w-full mt-2">
                        <p class="text-sm text-gray-500">ä¸Šæ¬¡æ—¥æœŸï¼š<span class="font-semibold text-gray-700">${formatDate(lastDateObj)}</span></p>
                        <p class="text-sm text-gray-500">ä¸Šæ¬¡æ•¸é‡ï¼š<span class="font-semibold text-gray-700">${lastQuantity}</span></p>
                    </div>
                    <div class="mt-4 pt-3 border-t border-gray-100 w-full text-right">
                        <p class="text-3xl font-extrabold ${daysSince > 90 ? 'text-red-600' : daysSince > 30 ? 'text-amber-600' : 'text-green-600'}">${daysSince}</p>
                        <p class="text-xs text-gray-500">å¤© (è·é›¢ä¸Šæ¬¡è³¼è²·)</p>
                    </div>
                `;
                container.appendChild(card);
            });

            // Register delete button event
            document.querySelectorAll('.delete-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    // ID in IndexedDB is a number, but data-id attribute is a string. Convert back.
                    const docId = parseInt(e.currentTarget.getAttribute('data-id'), 10);
                    const title = e.currentTarget.title.replace('åˆªé™¤æœ€è¿‘ä¸€ç­†ç´€éŒ„ (', '').replace(')', '');
                    const itemName = e.currentTarget.closest('.flex').querySelector('p').textContent;
                    
                    // Use custom modal instead of confirm()
                    showConfirmModal(`æ‚¨ç¢ºå®šè¦åˆªé™¤é€™ç­†ç´€éŒ„å—ï¼Ÿ\nç”¢å“ï¼š${itemName.substring(0, 20)}\nè©³ç´°ï¼š${title}`, () => {
                        deleteRecord(docId);
                    });
                });
            });
        };

        // Render average annual purchase summary (bottom panel)
        const renderSummary = (processedData) => {
            const container = document.getElementById('annualSummary');
            container.innerHTML = ''; 

            if (Object.keys(processedData).length === 0) {
                 container.innerHTML = `<div class="col-span-full text-gray-500 p-4 bg-gray-100 rounded-lg">
                    æ²’æœ‰è¶³å¤ çš„è³‡æ–™ä¾†è¨ˆç®—å¹³å‡å¹´è³¼è²·æ•¸é‡ã€‚
                </div>`;
                return;
            }

            // Sort by average quantity (highest first)
            const sortedSummaries = Object.entries(processedData).map(([name, data]) => {
                const totalQuantity = data.totalQuantity;
                // Calculate number of distinct years spanned by the data
                const firstYear = data.firstDate.getFullYear();
                const lastYear = data.lastDate.getFullYear();
                
                // Calculate the difference in years for calculation (min 1 year)
                let divisor = 1;
                if (firstYear !== lastYear) {
                    // This calculation is an approximation: 
                    // Use the time difference divided by 365.25 days to get the actual number of years span
                    const totalDays = (data.lastDate.getTime() - data.firstDate.getTime()) / (1000 * 60 * 60 * 24);
                    // Use the maximum of 1 year or the calculated year span
                    divisor = Math.max(1, totalDays / 365.25);
                } else {
                    // If all records are in the same year, the divisor is 1
                    divisor = 1; 
                }
                
                const avgAnnualQuantity = (totalQuantity / divisor).toFixed(2);
                const yearsSpanText = divisor === 1 ? '1 å¹´' : `${divisor.toFixed(1)} å¹´ç´€éŒ„`;

                return { name, avgAnnualQuantity, yearsSpanText };
            }).sort((a, b) => parseFloat(b.avgAnnualQuantity) - parseFloat(a.avgAnnualQuantity));


            sortedSummaries.forEach(({ name, avgAnnualQuantity, yearsSpanText }) => {
                const card = document.createElement('div');
                card.className = 'bg-white p-5 rounded-xl shadow-md border border-gray-100 hover:border-indigo-400 transition duration-150';

                card.innerHTML = `
                    <p class="text-lg font-medium text-gray-700 truncate mb-1" title="${name}">${name}</p>
                    <p class="text-4xl font-extrabold text-indigo-600 mt-1">${avgAnnualQuantity}</p>
                    <p class="text-sm text-gray-500">å¹³å‡æ¯å¹´è³¼è²·æ•¸é‡ (åŸºæ–¼ ${yearsSpanText})</p>
                `;
                container.appendChild(card);
            });
        };

        // Update the Quick Select Dropdown (formerly Datalist)
        const updateQuickSelect = (existingNames) => {
            const select = document.getElementById('quickSelect');
            // Keep the first default option
            select.innerHTML = '<option value="">-- è«‹é¸æ“‡æˆ–æ‰‹å‹•è¼¸å…¥ --</option>';
            
            const uniqueNames = [...new Set(existingNames)].sort(); 
            uniqueNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        };

        // Core data processing logic
        const processDataAndRender = (purchases) => {
            // Sort records by date: oldest first
            // IndexedDB stores Date objects directly, so no need for .toDate() conversion
            purchases.sort((a, b) => a.date.getTime() - b.date.getTime());

            const processedData = purchases.reduce((acc, purchase) => {
                const name = purchase.name.trim();

                if (!acc[name]) {
                    acc[name] = {
                        lastDate: purchase.date,
                        lastQuantity: purchase.quantity, 
                        firstDate: purchase.date,
                        totalQuantity: 0,
                        records: [],
                    };
                }
                
                // Always update to the latest record (because we sorted purchases)
                if (purchase.date.getTime() >= acc[name].lastDate.getTime()) {
                    acc[name].lastDate = purchase.date;
                    acc[name].lastQuantity = purchase.quantity; 
                }

                // Find the earliest record
                if (purchase.date.getTime() < acc[name].firstDate.getTime()) {
                    acc[name].firstDate = purchase.date;
                }

                acc[name].totalQuantity += purchase.quantity;
                acc[name].records.push(purchase);
                return acc;
            }, {});

            const existingNames = Object.keys(processedData);

            renderOverview(processedData);
            renderSummary(processedData);
            updateQuickSelect(existingNames); // Update the dropdown instead of datalist
        };


        // --- IndexedDB Interaction and Main Logic ---

        // Load all data from IndexedDB and trigger rendering
        const loadAndRenderData = async () => {
            if (!isDbReady) return;
            try {
                const purchases = await getAllItems();
                processDataAndRender(purchases);
            } catch (error) {
                console.error("Failed to load data from IndexedDB:", error);
                showMessage("è³‡æ–™è¼‰å…¥å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç€è¦½å™¨å„²å­˜æˆ–æ¬Šé™ã€‚", true);
            }
        };

        // Handle record deletion
        const deleteRecord = async (docId) => {
            if (!isDbReady) {
                showMessage("è³‡æ–™åº«é€£ç·šå°šæœªå°±ç·’ï¼Œç„¡æ³•åŸ·è¡Œåˆªé™¤æ“ä½œã€‚", true);
                return;
            }
            try {
                // Wait for the deletion
                await deleteItem(docId); 
                showMessage("âœ… ç´€éŒ„å·²æˆåŠŸåˆªé™¤ï¼");
                // Refresh data
                await loadAndRenderData(); 
            } catch (error) {
                console.error("Failed to delete IndexedDB record:", error);
                showMessage(`åˆªé™¤å¤±æ•—: ${error.message}`, true);
            }
        };


        // Handle form submission
        const handleFormSubmit = async (event) => {
            event.preventDefault();

            // Ensure DB is ready
            if (!isDbReady) {
                showMessage("è³‡æ–™åº«é€£ç·šå°šæœªå®Œæˆï¼Œè«‹ç¨å€™å†è©¦æˆ–é‡æ–°æ•´ç†é é¢ã€‚", true);
                return;
            }

            const form = event.target;
            const itemName = form.itemName.value.trim();
            const purchaseDateStr = form.purchaseDate.value;
            const purchaseAmount = parseFloat(form.purchaseAmount.value);
            const purchaseQuantity = parseInt(form.purchaseQuantity.value, 10);

            if (!itemName || isNaN(purchaseAmount) || isNaN(purchaseQuantity) || purchaseQuantity <= 0 || purchaseAmount < 0) {
                showMessage("è«‹ç¢ºèªæ‰€æœ‰æ¬„ä½å‡å·²æ­£ç¢ºå¡«å¯«ï¼ˆåç¨±ä¸å¯ç©ºç™½ï¼Œé‡‘é¡/æ•¸é‡å¿…é ˆç‚ºæœ‰æ•ˆæ•¸å­—ä¸”æ•¸é‡éœ€å¤§æ–¼ 0ï¼‰ã€‚", true);
                return;
            }

            // Convert date string to Date object
            const purchaseDate = new Date(purchaseDateStr);
            // Ensure the date is correctly captured at midnight UTC for consistency
            purchaseDate.setUTCHours(0, 0, 0, 0);

            try {
                // Temporarily disable the button to prevent double submission
                updateSubmitButton(false); 
                document.getElementById('submitButton').textContent = 'å„²å­˜ä¸­...';

                const newRecord = {
                    name: itemName,
                    date: purchaseDate, // Stored as Date object in IndexedDB
                    amount: purchaseAmount,
                    quantity: purchaseQuantity,
                    // IndexedDB will automatically assign the 'id'
                };

                await addItem(newRecord);

                showMessage(`æˆåŠŸå„²å­˜ï¼š${itemName} è³¼è²· ${purchaseQuantity} ä»½ï¼`);
                form.reset();
                setInitialDate(); // Reset date to today
                
                // Reset the select dropdown as well
                document.getElementById('quickSelect').value = "";
                
                // Refresh data after mutation
                await loadAndRenderData();

            } catch (error) {
                console.error("Failed to write to IndexedDB:", error);
                // Ensure the error message is shown to the user
                showMessage(`å„²å­˜å¤±æ•—: ${error.message}`, true);
            } finally {
                // Re-enable the button regardless of success/failure
                updateSubmitButton(true);
            }
        };

        // --- Application Main Entry Point ---
        const initApp = async () => {
            try {
                // 1. Initialize IndexedDB
                await openDB();
                console.log("IndexedDB connection successful.");
                
                // 2. Set UI state and load data
                updateSubmitButton(true); 
                await loadAndRenderData();

                // 3. Register form event
                document.getElementById('purchaseForm').addEventListener('submit', handleFormSubmit);

                // 4. Register Quick Select change event
                document.getElementById('quickSelect').addEventListener('change', (e) => {
                    const selectedValue = e.target.value;
                    if (selectedValue) {
                        document.getElementById('itemName').value = selectedValue;
                    }
                });

            } catch (error) {
                console.error("Application initialization failed:", error);
                document.getElementById('overviewList').innerHTML = `<div class="col-span-full text-red-500 p-4 bg-red-100 rounded-lg border border-red-200">
                    ğŸ”´ éŒ¯èª¤ï¼šç„¡æ³•é€£ç·šåˆ°æœ¬åœ°è³‡æ–™åº«ã€‚è«‹æª¢æŸ¥æ‚¨çš„ç€è¦½å™¨æ˜¯å¦å…è¨±ä½¿ç”¨ IndexedDBã€‚
                </div>`;
                updateSubmitButton(false);
            }
        };
        
        // Set the initial date immediately
        setInitialDate();

        // Start the application when the page is loaded
        window.onload = initApp;

    </script>
</body>
</html>